#ifndef SIMPLEBUFFERS__SIMPLEBUFFERS__ZACHDACHAMPION__HPP
#define SIMPLEBUFFERS__SIMPLEBUFFERS__ZACHDACHAMPION__HPP

#include <cstdint>
#include <cstring>

namespace simplebuffers {

//                                                                                                //
// ===================================== SimpleBufferWriter ===================================== //
//                                                                                                //

/**
 * @brief An abstract base class for any class that can be written to a SimpleBuffer.
 *
 * All Sequences and OneOfs that are generated by the SimpleBuffers compiler inherit from this
 * class. A special ListWriter class is also provided for writing arrays.
 */
class SimpleBufferWriter {
   public:
    /**
     * @brief Returns the static size of the object.
     *
     * The number returned by this function represents the size of all statically-sized fields in
     * a component. Dynamically-sized fields are not included in this number, but relative offsets
     * are. These offsets are used to determine the location of dynamically-sized fields in the
     * buffer.
     *
     * @return The static size of the object.
     */
    virtual uint16_t static_size() const = 0;

    /**
     * @brief Writes a component to the destination buffer.
     *
     * Generally, this method should not be called directly. Instead, call the write() method. When
     * implementing this method in a derived class, keep the following in mind:
     *
     * - All static data should be written at `dest`.
     *
     * - All dynamic data should be written at `dyn_cursor`.
     *
     * - Fields should be written using the `write_field()` function, which will automatically
     *   handle dynamic data. Make sure to update `dyn_cursor` after writing each field. If a
     *   nullptr is returned, exit immediately and return nullptr.
     *
     * - This function assumes that space has already been reserved for the static data in the
     *   destination buffer. Therefore, there is no need to perform any checks when writing static
     *   data.
     *
     * - You MUST check for space in the destination buffer before writing dynamic data.
     *   `dyn_cursor` will always be after the static data, so the remaining buffer space is
     *   `dest_end - dyn_cursor`. If there is not enough space, return `nullptr`. You must also do
     *   this after calling `write_field()`, since it may write dynamic data.
     *
     * - After writing the dynamic data, you MUST return a pointer to the first free byte in the
     *   dynamic section of the buffer. This is the byte immediately after the last dynamic byte you
     *   wrote. If you did not write any dynamic data, return `dyn_cursor`.
     *
     * @param dest The destination to write static data to.
     * @param dest_end The end of the destination buffer.
     * @param dyn_cursor A dynamic cursor used for writing variable-length data.
     * @return A pointer to the end of the dynamic data written to the buffer, or `nullptr` if the
     *         buffer was too small.
     */
    virtual uint8_t* write_component(uint8_t* dest, const uint8_t* dest_end,
                                     uint8_t* dyn_cursor) const = 0;

    /**
     * @brief Serializes the component to the destination buffer.
     *
     * This method should not be overridden by derived classes. Instead, derived classes should
     * implement the write_component() method.
     *
     * @param dest The destination buffer to write the data to.
     * @param dest_size The size of the destination buffer.
     * @return The number of bytes written to the destination buffer, or -1 if the buffer was too
     *         small.
     */
    int32_t write(uint8_t* dest, uint16_t dest_size) const {
        uint8_t* res = write_component(dest, dest + dest_size, dest + static_size());
        if (res == nullptr) return -1;
        return res - dest;
    }
};

//                                                                                                //
// ========================================= ListWriter ========================================= //
//                                                                                                //

/**
 * @brief A class for writing arrays to a simple buffer.
 *
 * @note Unlike most of SimpleBuffers, this class does *not* inherit from SimpleBufferWriter and
 *       cannot be used to directly serialize data. A priv::ListWriterImpl, which does inherit from
 *       SimpleBufferWriter, must be constructed using data from this ListWriter after properly
 *       casting enums to their underlying serialization type.
 *
 * @tparam T The type of the array elements.
 */
template <typename T>
class ListWriter {
   public:
    /**
     * @brief Constructs a ListWriter object.
     *
     * @param val Pointer to the array.
     * @param len Length of the array.
     */
    ListWriter(T* const val, uint16_t len) : val(val), len(len) {}

    T* const val;
    uint16_t len;
};

//                                                                                                //
// ====================================== priv::ListWriter ====================================== //
//                                                                                                //

namespace priv {

/**
 * @brief A class for writing arrays to a simple buffer.
 *
 * @tparam T The type of the array elements.
 */
template <typename T>
class ListWriterImpl : public SimpleBufferWriter {
   public:
    /**
     * @brief Constructs a ListWriter object.
     *
     * @param val Pointer to the array.
     * @param len Length of the array.
     */
    ListWriterImpl(T* const val, uint16_t len) : val_(val), len_(len) {}

    uint16_t static_size() const override { return 4; }

    uint8_t* write_component(uint8_t* dest, const uint8_t* dest_end,
                             uint8_t* dyn_cursor = nullptr) const override {
        uint16_t offset = dyn_cursor - dest;
        dest[0] = len_ & 0xFF;
        dest[1] = len_ >> 8;
        dest[2] = offset & 0xFF;
        dest[3] = offset >> 8;

        return write_data_(dyn_cursor, dest_end, val_, len_);
    }

   protected:
    /**
     * @brief Writes the data of an array to a destination buffer.
     *
     * This function is specialized for uint8_t and int8_t because they can be written efficiently
     * with memcpy without worrying about endianness.
     *
     * @tparam T The type of the array elements.
     * @param dest The destination buffer to write the data to.
     * @param dest_end Pointer to the end of the destination buffer.
     * @param val Pointer to the data to be written.
     * @param len The length of the data to be written.
     * @return Pointer to the next position in the destination buffer after writing the data.
     */
    static uint8_t* write_data_(uint8_t* dest, const uint8_t* dest_end, T* val, uint16_t len) {
        uint16_t element_static_size = (len > 0) ? get_static_size(val[0]) : 0;
        uint16_t total_static_size = element_static_size * len;
        if (dest + total_static_size > dest_end) return nullptr;

        // Create a pointer to the end of the static array data. This is where the dynamic data of
        // the elements will be written.
        uint8_t* dyn_cursor = dest + total_static_size;

        // Write each element to the buffer.
        for (uint16_t i = 0; i < len; ++i) {
            uint8_t* res = write_field(dest, dest_end, dyn_cursor, val[i]);
            if (res == nullptr) return nullptr;
            dest += element_static_size;
            dyn_cursor = res;
        }

        return dyn_cursor;
    }

    T* const val_;  ///< Pointer to the array.
    uint16_t len_;  ///< Length of the array.
};

/**
 * Efficiently writes u8 data from the source array to the destination array.
 *
 * @param dest Pointer to the destination array.
 * @param dest_end Pointer to the end of the destination array.
 * @param val Pointer to the source array.
 * @param len Length of the source array.
 * @return Pointer to the next position in the destination array after writing the data.
 */
template <>
inline uint8_t* ListWriterImpl<uint8_t>::write_data_(uint8_t* dest, const uint8_t* dest_end,
                                                     uint8_t* val, uint16_t len) {
    uint16_t total_static_size = len;
    if (dest + total_static_size > dest_end) return nullptr;

    memcpy(dest, val, len);
    return dest + total_static_size;
}

/**
 * Efficiently writes i8 data from the source array to the destination array.
 *
 * @param dest Pointer to the destination array.
 * @param dest_end Pointer to the end of the destination array.
 * @param val Pointer to the source array.
 * @param len Length of the source array.
 * @return Pointer to the next position in the destination array after writing the data.
 */
template <>
inline uint8_t* ListWriterImpl<int8_t>::write_data_(uint8_t* dest, const uint8_t* dest_end,
                                                    int8_t* val, uint16_t len) {
    uint16_t total_static_size = len;
    if (dest + total_static_size > dest_end) return nullptr;

    memcpy(dest, val, len);
    return dest + total_static_size;
}

}  // namespace priv

//                                                                                                //
// ======================================== OneOfWriter ========================================= //
//                                                                                                //

/**
 * @brief An abstract class for writing OneOf fields to a simple buffer. Specific OneOf writers
 *        should inherit from this class.
 */
class OneOfWriter : public SimpleBufferWriter {
   public:
    /**
     * @brief The static size of all OneOf structures is 3 bytes: 1 byte for the tag and 2 bytes for
     *        the offset.
     *
     * @return The static size of the OneOf structure (3);
     */
    uint16_t static_size() const override { return 3; }
};

//                                                                                                //
// ====================================== Get static size ======================================= //
//                                                                                                //

/**
 * @brief Returns the static size of a given value.
 *
 * This does not include dynamic data, such as strings or arrays.
 *
 * @param val The value to calculate the static size for.
 * @return The static size of the value.
 */
inline uint16_t get_static_size(const uint8_t val) { return 1; }
inline uint16_t get_static_size(const int8_t val) { return 1; }
inline uint16_t get_static_size(const uint16_t val) { return 2; }
inline uint16_t get_static_size(const int16_t val) { return 2; }
inline uint16_t get_static_size(const uint32_t val) { return 4; }
inline uint16_t get_static_size(const int32_t val) { return 4; }
inline uint16_t get_static_size(const uint64_t val) { return 8; }
inline uint16_t get_static_size(const int64_t val) { return 8; }
inline uint16_t get_static_size(const float val) { return 4; }
inline uint16_t get_static_size(const double val) { return 8; }
inline uint16_t get_static_size(const bool val) { return 1; }
inline uint16_t get_static_size(const SimpleBufferWriter& val) { return val.static_size(); }
inline uint16_t get_static_size(char* const& val) { return 2; }

//                                                                                                //
// ======================================== Write field ========================================= //
//                                                                                                //

/**
 * @brief Writes a field value to the destination buffer.
 *
 * @param dest The destination to write static data to.
 * @param dest_end The end of the destination buffer.
 * @param dyn_cursor The dynamic cursor for writing variable-length fields.
 * @param val The value to write.
 * @return A pointer to the end of the dynamic data written to the buffer, or `nullptr` if the
 *         buffer was too small.
 */
inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            const uint8_t& val) {
    dest[0] = val;
    return dyn_cursor;
}

inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            const int8_t& val) {
    dest[0] = val;
    return dyn_cursor;
}

inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            const uint16_t& val) {
    dest[0] = val & 0xFF;
    dest[1] = val >> 8;
    return dyn_cursor;
}

inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            const int16_t& val) {
    dest[0] = val & 0xFF;
    dest[1] = val >> 8;
    return dyn_cursor;
}

inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            const uint32_t& val) {
    dest[0] = val & 0xFF;
    dest[1] = val >> 8;
    dest[2] = val >> 16;
    dest[3] = val >> 24;
    return dyn_cursor;
}

inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            const int32_t& val) {
    dest[0] = val & 0xFF;
    dest[1] = val >> 8;
    dest[2] = val >> 16;
    dest[3] = val >> 24;
    return dyn_cursor;
}

inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            const uint64_t& val) {
    dest[0] = val & 0xFF;
    dest[1] = val >> 8;
    dest[2] = val >> 16;
    dest[3] = val >> 24;
    dest[4] = val >> 32;
    dest[5] = val >> 40;
    dest[6] = val >> 48;
    dest[7] = val >> 56;
    return dyn_cursor;
}

inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            const int64_t& val) {
    dest[0] = val & 0xFF;
    dest[1] = val >> 8;
    dest[2] = val >> 16;
    dest[3] = val >> 24;
    dest[4] = val >> 32;
    dest[5] = val >> 40;
    dest[6] = val >> 48;
    dest[7] = val >> 56;
    return dyn_cursor;
}

inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            const float& val) {
    uint32_t val_int;
    memcpy(&val_int, &val, sizeof(uint32_t));  // Only legal way to do this pre C++ 20
    dest[0] = val_int & 0xFF;
    dest[1] = val_int >> 8;
    dest[2] = val_int >> 16;
    dest[3] = val_int >> 24;
    return dyn_cursor;
}

inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            const double& val) {
    uint64_t val_int;
    memcpy(&val_int, &val, sizeof(uint64_t));  // Only legal way to do this pre C++ 20
    dest[0] = val_int & 0xFF;
    dest[1] = val_int >> 8;
    dest[2] = val_int >> 16;
    dest[3] = val_int >> 24;
    dest[4] = val_int >> 32;
    dest[5] = val_int >> 40;
    dest[6] = val_int >> 48;
    dest[7] = val_int >> 56;
    return dyn_cursor;
}

inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            const bool& val) {
    dest[0] = val ? 1 : 0;
    return dyn_cursor;
}

inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            char* const& val) {
    uint16_t str_len = strlen(val);
    if (dyn_cursor + str_len + 1 > dest_end) return nullptr;  // +1 for null terminator

    // Write the data offset to the static section of the buffer.
    uint16_t offset = dyn_cursor - dest;
    dest[0] = offset & 0xFF;
    dest[1] = offset >> 8;

    // Write the string to the dynamic section of the buffer.
    memcpy(dyn_cursor, val, str_len + 1);
    dyn_cursor += str_len + 1;

    return dyn_cursor;
}

inline uint8_t* write_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor,
                            const SimpleBufferWriter& val) {
    return val.write_component(dest, dest_end, dyn_cursor);
}

/**
 * @brief Writes a OneOf field to the destination buffer.
 *
 * @param[out] dest The destination to write static data to.
 * @param[in] dest_end The end of the destination buffer.
 * @param[out] dyn_cursor The dynamic cursor for writing variable-length fields.
 * @param[in] tag The tag of the OneOf field.
 * @param[in] val The value to write.
 * @return A pointer to the end of the dynamic data written to the buffer, or `nullptr` if the
 *         buffer was too small.
 */
template <typename T>
uint8_t* write_oneof_field(uint8_t* dest, const uint8_t* dest_end, uint8_t* dyn_cursor, uint8_t tag,
                           const T& val) {
    uint16_t static_size = get_static_size(val);
    if (dyn_cursor + static_size > dest_end) return nullptr;

    // Write the tag and offset to the static section of the buffer.
    uint16_t offset = dyn_cursor - dest;
    dest[0] = tag;
    dest[1] = offset & 0xFF;
    dest[2] = offset >> 8;

    return write_field(dyn_cursor, dest_end, dyn_cursor + static_size, val);
};

//                                                                                                //
// ===================================== SimpleBufferReader ===================================== //
//                                                                                                //

class SimpleBufferReader {
   public:
    /**
     * Construct a new Reader object.
     *
     * @param[in] data_ptr A pointer to this component's location in a data buffer.
     * @param[in] idx An index that can be used to address a later contiguous instance of this
     *                Reader. Used when instantiating from an array.
     */
    SimpleBufferReader(const uint8_t* data_ptr) : data_ptr_(data_ptr) {}

    /**
     * @brief Returns a pointer to this component in the data buffer.
     *
     * @return Pointer to the component in the data buffer.
     */
    const uint8_t* data() const { return data_ptr_; }

    /**
     * @brief Returns the static size of the object.
     *
     * The number returned by this function represents the size of all statically-sized fields in
     * a component. Dynamically-sized fields are not included in this number, but relative offsets
     * are. These offsets are used to determine the location of dynamically-sized fields in the
     * buffer.
     *
     * @return The static size of the object.
     */
    virtual uint16_t static_size() const = 0;

   protected:
    const uint8_t* data_ptr_;
};

//                                                                                                //
// ========================================= Read field ========================================= //
//                                                                                                //

template <typename T>
inline T read_field(const uint8_t* src, uint16_t idx = 0) {
    return T(src, idx);
}

/**
 * @brief Reads a u8 field from a buffer.
 *
 * @param src The destination to read static data from.
 */
template <>
inline uint8_t read_field<>(const uint8_t* src, uint16_t idx) {
    src += idx;
    return *src;
}

/**
 * @brief Reads an i8 field from a buffer.
 *
 * @param src The destination to read static data from.
 */
template <>
inline int8_t read_field<>(const uint8_t* src, uint16_t idx) {
    src += idx;
    return *src;
}

/**
 * @brief Reads a u16 field from a buffer.
 *
 * @param src The destination to read static data from.
 */
template <>
inline uint16_t read_field<>(const uint8_t* src, uint16_t idx) {
    src += idx * 2;
    uint16_t val = 0;
    val |= src[0] << 0;
    val |= src[1] << 8;
    return val;
}

/**
 * @brief Reads an i16 field from a buffer.
 *
 * @param src The destination to read static data from.
 */
template <>
inline int16_t read_field<>(const uint8_t* src, uint16_t idx) {
    src += idx * 2;
    int16_t val = 0;
    val |= src[0] << 0;
    val |= src[1] << 8;
    return val;
}

/**
 * @brief Reads a u32 field from a buffer.
 *
 * @param src The destination to read static data from.
 */
template <>
inline uint32_t read_field<>(const uint8_t* src, uint16_t idx) {
    src += idx * 4;
    uint32_t val = 0;
    val |= src[0] << 0;
    val |= src[1] << 8;
    val |= src[2] << 16;
    val |= src[3] << 24;
    return val;
}

/**
 * @brief Reads an i32 field from a buffer.
 *
 * @param src The destination to read static data from.
 */
template <>
inline int32_t read_field<>(const uint8_t* src, uint16_t idx) {
    src += idx * 4;
    int32_t val = 0;
    val |= src[0] << 0;
    val |= src[1] << 8;
    val |= src[2] << 16;
    val |= src[3] << 24;
    return val;
}

/**
 * @brief Reads a u64 field from a buffer.
 *
 * @param src The destination to read static data from.
 */
template <>
inline uint64_t read_field<>(const uint8_t* src, uint16_t idx) {
    src += idx * 8;
    uint64_t val = 0;
    val |= src[0] << 0;
    val |= src[1] << 8;
    val |= src[2] << 16;
    val |= src[3] << 24;
    val |= (uint64_t)src[4] << 32;
    val |= (uint64_t)src[5] << 40;
    val |= (uint64_t)src[6] << 48;
    val |= (uint64_t)src[7] << 56;
    return val;
}

/**
 * @brief Reads an i64 field from a buffer.
 *
 * @param src The destination to read static data from.
 */
template <>
inline int64_t read_field<>(const uint8_t* src, uint16_t idx) {
    src += idx * 8;
    int64_t val = 0;
    val |= src[0] << 0;
    val |= src[1] << 8;
    val |= src[2] << 16;
    val |= src[3] << 24;
    val |= (uint64_t)src[4] << 32;
    val |= (uint64_t)src[5] << 40;
    val |= (uint64_t)src[6] << 48;
    val |= (uint64_t)src[7] << 56;
    return val;
}

/**
 * @brief Reads an f32 field from a buffer.
 *
 * @param src The destination to read static data from.
 */
template <>
inline float read_field<float>(const uint8_t* src, uint16_t idx) {
    src += idx * 4;
    uint32_t val_int = 0;
    float val;
    val_int |= src[0] << 0;
    val_int |= src[1] << 8;
    val_int |= src[2] << 16;
    val_int |= src[3] << 24;
    memcpy(&val, &val_int, sizeof(float));
    return val;
}

/**
 * @brief Reads an f64 field from a buffer.
 *
 * @param src The destination to read static data from.
 */
template <>
inline double read_field<double>(const uint8_t* src, uint16_t idx) {
    src += idx * 8;
    uint64_t val_int = 0;
    double val;
    val_int |= src[0] << 0;
    val_int |= src[1] << 8;
    val_int |= src[2] << 16;
    val_int |= src[3] << 24;
    val_int |= (uint64_t)src[4] << 32;
    val_int |= (uint64_t)src[5] << 40;
    val_int |= (uint64_t)src[6] << 48;
    val_int |= (uint64_t)src[7] << 56;
    memcpy(&val, &val_int, sizeof(double));
    return val;
}

/**
 * @brief Reads a bool field from a buffer.
 *
 * @param src The destination to read static data from.
 */
template <>
inline bool read_field<>(const uint8_t* src, uint16_t idx) {
    src += idx;
    return *src ? true : false;
}

/**
 * @brief Reads a string field from a buffer.
 *
 * @param src The destination to read data from.
 * @param[in] idx An index that can be used to address a later contiguous instance of this
 *                Reader. Used when instantiating from an array.
 */
template <>
inline const char* read_field(const uint8_t* src, uint16_t idx) {
    const uint16_t offset = read_field<uint16_t>(src, idx);
    return reinterpret_cast<const char*>(src + offset);
}

//                                                                                                //
// ======================================== ListReader ========================================= //
//                                                                                                //

/**
 * @brief A class for reading arrays from a simple buffer.
 *
 * @tparam REA The type to read from the buffer.
 * @tparam RET The type to return (cast from read).
 */
template <typename RET, typename REA = RET>
class ListReader : public SimpleBufferReader {
   public:
    /**
     * Construct a new Reader object.
     *
     * @param[in] data_ptr A pointer to this component's location in a data buffer.
     * @param[in] idx
     */
    ListReader(const uint8_t* data_ptr, size_t idx) : SimpleBufferReader(data_ptr + 4 * idx) {
        array_len_ = read_field<uint16_t>(data_ptr);
        array_content_ = data_ptr + read_field<uint16_t>(data_ptr + 2);
    }

    /**
     * Get the number of elements in the array.
     *
     * @return The length of the array.
     */
    uint16_t len() const { return array_len_; }

    /**
     * Read the value at index `idx` from the array.
     *
     * This function does not check bounds and has undefined behavior if an out-of-bounds index is
     * given.
     *
     * @param[in] idx The index to read.
     * @return The value read from the array.
     */
    RET read(uint16_t idx) const { return static_cast<RET>(read_field<REA>(array_content_, idx)); }

    /**
     * Read the value at index `idx` from the array.
     *
     * This function does not check bounds and has undefined behavior if an out-of-bounds index is
     * given.
     *
     * @param[in] idx The index to read.
     * @return The value read from the array.
     */
    RET operator[](uint16_t idx) const { return read(idx); }

    /**
     * @brief Returns the static size of the object.
     *
     * The number returned by this function represents the size of all statically-sized fields in
     * a component. Dynamically-sized fields are not included in this number, but relative offsets
     * are. These offsets are used to determine the location of dynamically-sized fields in the
     * buffer.
     *
     * @return The static size of the object.
     */
    uint16_t static_size() const override { return 4; }

   protected:
    uint16_t array_len_;
    const uint8_t* array_content_;
};

//                                                                                                //
// ======================================== OneOf Reader ======================================== //
//                                                                                                //

/**
 * @brief A class for reading OneOf fields from a simple buffer. Specific OneOf readers should
 *        inherit from this class.
 */
class OneOfReader : public SimpleBufferReader {
   public:
    /**
     * Construct a new OneOfReader object.
     *
     * @param[in] data_ptr A pointer to this component's location in a data buffer.
     * @param[in] idx An index that can be used to address a later contiguous instance of this
     *                Reader. Used when instantiating from an array.
     */
    OneOfReader(const uint8_t* data_ptr, size_t idx) : SimpleBufferReader(data_ptr + 3 * idx) {}

    /**
     * @brief Returns the static size of the object.
     *
     * The number returned by this function represents the size of all statically-sized fields in
     * a component. Dynamically-sized fields are not included in this number, but relative offsets
     * are. These offsets are used to determine the location of dynamically-sized fields in the
     * buffer.
     *
     * @return The static size of the object.
     */
    uint16_t static_size() const override { return 4; }

   protected:
    const uint8_t* val_ptr_;
};

}  // namespace simplebuffers

#endif  // SIMPLEBUFFERS__SIMPLEBUFFERS__ZACHDACHAMPION__HPP